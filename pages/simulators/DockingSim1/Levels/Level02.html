<!DOCTYPE html>
<html lang="en">
<head>
    <!--
      NASA JPL Class-D Docking Simulator — LEVEL 2
      "OPERATION CASCADE"
      ─────────────────────────────────────────────────────
      MISSION PROFILE:
        PHASE 1 — INTERCEPT BURN (140m → ~70m)
          Navigate through debris field to RENDEZVOUS WAYPOINT.
          Match velocity with tumbling derelict satellite (ISS-7R).
        PHASE 2 — STATION-KEEPING (70m → 20m)
          Hold formation with drifting target. Avoid collision debris.
          Align roll-axis with rotating docking collar.
        PHASE 3 — FINAL APPROACH (20m → 0)
          Guide probe into port. Center guide square must contain target.
          Speed < 0.25 m/s. Deviation < 0.6m.
      ─────────────────────────────────────────────────────
      NEW MECHANICS vs LVL1:
        • Asteroid / debris field — vector-polygon rocks with physics
        • Tumbling derelict satellite target (rotating docking collar)
        • Rendezvous waypoint ring at 70m — must pass through
        • Dead satellite drifting on random trajectory — must intercept
        • Second orbiting dead sat that creates close-pass hazard
        • Solar-wind drift — slow constant lateral force
        • Proximity warning at 8m from debris
        • Fuel consumption 2× higher than LVL1
        • Hard collision with any debris = mission abort
    -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NASA JPL — LEVEL 2: OPERATION CASCADE</title>
    <style>
        :root {
            --ng:  #00ff41;
            --ng2: #00cc33;
            --dg:  #003b00;
            --bg:  #020408;
            --red: #ff3333;
            --amb: #ffb100;
            --cya: #00e5ff;
            --pur: #aa44ff;
            --dim: rgba(0,255,65,0.12);
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            background: var(--bg);
            color: var(--ng);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            user-select: none;
        }
        #wrap {
            position: relative;
            width: 95vw;
            max-width: 960px;
            aspect-ratio: 16/9;
            border: 3px solid #1a2a1a;
            border-radius: 8px;
            background: #000;
            overflow: hidden;
            cursor: crosshair;
            box-shadow: 0 0 60px rgba(0,30,0,0.8), inset 0 0 120px rgba(0,20,0,0.4);
        }
        canvas { display: block; width: 100%; height: 100%; }
        .ov {
            position: absolute;
            pointer-events: none;
            font-weight: bold;
            letter-spacing: 1.2px;
            text-transform: uppercase;
            font-size: 12px;
        }
        #telem {
            top: 18px; left: 18px;
            background: rgba(0,8,0,0.88);
            border: 1px solid #0a2a0a;
            padding: 10px 14px;
            line-height: 1.55;
            z-index: 15;
        }
        #status {
            top: 18px; right: 18px;
            text-align: right;
            background: rgba(0,8,0,0.88);
            border: 1px solid #0a2a0a;
            padding: 10px 14px;
            line-height: 1.55;
            z-index: 15;
        }
        #phase-bar {
            position: absolute;
            bottom: 18px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 6px;
            z-index: 15;
            pointer-events: none;
        }
        .phase-node {
            padding: 4px 14px;
            border: 1px solid #0a2a0a;
            background: rgba(0,8,0,0.88);
            font-size: 10px;
            font-weight: bold;
            letter-spacing: 1px;
            color: #224422;
        }
        .phase-node.active { color: var(--ng); border-color: var(--ng); }
        .phase-node.done   { color: #336633; border-color: #224422; }
        .scanlines {
            position: absolute; inset: 0;
            background: repeating-linear-gradient(
                0deg, rgba(0,0,0,0) 0px, rgba(0,0,0,0) 2px,
                rgba(0,0,0,0.18) 2px, rgba(0,0,0,0.18) 3px
            );
            z-index: 20; pointer-events: none; opacity: 0.4;
        }
        .vignette {
            position: absolute; inset: 0;
            background: radial-gradient(ellipse at center, transparent 55%, rgba(0,0,0,0.75) 100%);
            z-index: 21; pointer-events: none;
        }
        #modal {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%,-50%);
            background: #000;
            border: 2px solid var(--ng);
            padding: 36px 48px;
            text-align: center;
            z-index: 100;
            min-width: 380px;
            box-shadow: 0 0 80px rgba(0,0,0,0.95), 0 0 30px rgba(0,255,65,0.1);
        }
        #modal h1 { margin: 0 0 12px; font-size: 22px; }
        #modal p  { font-size: 13px; line-height: 1.6; color: #88bb88; margin-bottom: 8px; }
        button {
            background: transparent; color: var(--ng);
            border: 1px solid var(--ng);
            padding: 12px 28px; cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px; font-weight: bold;
            margin-top: 20px; transition: all 0.2s;
        }
        button:hover { background: var(--ng); color: #000; box-shadow: 0 0 20px var(--ng); }
        #flash { position: absolute; inset: 0; opacity: 0; pointer-events: none; z-index: 25; transition: opacity 0.08s; }
        .warn  { color: var(--red); animation: blink 0.5s infinite; }
        .ok    { color: #fff; }
        .crit  { color: var(--amb); animation: blink 0.25s infinite; }
        .info  { color: var(--cya); }
        @keyframes blink { 50% { opacity: 0.08; } }

        #hint {
            margin-top: 14px;
            font-size: 11px;
            color: #3a4a3a;
            text-align: center;
            line-height: 1.7;
            letter-spacing: 0.5px;
        }
    </style>
</head>
<body>
<div id="wrap">
    <div id="flash"></div>
    <div class="scanlines"></div>
    <div class="vignette"></div>

    <div id="telem" class="ov">
        &gt; RANGE: <span id="v-z">0.00</span>m<br>
        &gt; X-DEV: <span id="v-x">0.00</span>m<br>
        &gt; Y-DEV: <span id="v-y">0.00</span>m<br>
        &gt; VEL-Z: <span id="v-vz">0.00</span>m/s<br>
        &gt; FUEL:  <span id="v-fuel">100</span>%<br>
        &gt; PHASE: <span id="v-phase">---</span>
    </div>

    <div id="status" class="ov">
        [ LVL2 · OPERATION CASCADE ]<br>
        TGT-VX: <span id="v-tvx">0.00</span> m/s<br>
        TGT-VY: <span id="v-tvy">0.00</span> m/s<br>
        REL-V:  <span id="v-relv">0.00</span> m/s<br>
        COLLAR: <span id="v-collar">---</span>°<br>
        <span id="align-stat">AWAITING INIT</span>
    </div>

    <div id="phase-bar">
        <div class="phase-node" id="ph1">① INTERCEPT</div>
        <div class="phase-node" id="ph2">② RENDEZVOUS</div>
        <div class="phase-node" id="ph3">③ APPROACH</div>
        <div class="phase-node" id="ph4">④ DOCK</div>
    </div>

    <canvas id="c"></canvas>

    <div id="modal">
        <h1 id="m-title" style="color:var(--ng)">LEVEL 2 — OPERATION CASCADE</h1>
        <p id="m-desc">
            ISS-7R derelict is tumbling in low orbit.<br>
            Navigate debris field → rendezvous at 70m → match velocity<br>
            → align with rotating collar → dock.<br><br>
            <span style="color:var(--amb)">⚠ Debris impact = mission abort. Fuel is limited.</span>
        </p>
        <p style="color:#446644; font-size:11px">
            WASD / ARROWS — translate &nbsp;|&nbsp; Q/E — fore/aft &nbsp;|&nbsp; SPACE — brake<br>
            [V] toggle view &nbsp;|&nbsp; [T] toggle mouse/kbd
        </p>
        <button onclick="startSim()">INITIATE MISSION</button>
    </div>
</div>

<div id="hint">
    <b>[V]</b> CYCLE VIEW &nbsp;|&nbsp; <b>[T]</b> SWITCH INPUT &nbsp;|&nbsp; <b>[SPACE]</b> BRAKE (RCS NULL-VELOCITY)<br>
    <b>FPV:</b> WASD=X/Y &nbsp; Q/E=Z &nbsp;|&nbsp; <b>SIDE:</b> W/S=Y &nbsp; A/D=Z &nbsp;|&nbsp; MATCH TGT VELOCITY AT WAYPOINT
</div>

<script>
// ═══════════════════════════════════════════════════════
// CANVAS / CONTEXT
// ═══════════════════════════════════════════════════════
const canvas = document.getElementById('c');
const wrap   = document.getElementById('wrap');
const ctx    = canvas.getContext('2d');
const flash  = document.getElementById('flash');
const modal  = document.getElementById('modal');

// ═══════════════════════════════════════════════════════
// CONSTANTS
// ═══════════════════════════════════════════════════════
const THRUST       = 0.00075;
const BRAKE        = 0.92;
const DOCK_RANGE   = 0.35;
const MAX_DOCK_SPD = 0.25;
const ALIGN_TOL    = 0.60;
const GUIDE_HALF   = 38;
const SOLAR_DRIFT  = 0.000018; // constant lateral push (solar wind sim)
const RENDEZVOUS_Z = 68;       // waypoint Z distance
const PHASE_APPROACH_Z = 20;   // transition to final approach

// ═══════════════════════════════════════════════════════
// AUDIO
// ═══════════════════════════════════════════════════════
let audio = null;
let thrGain, proxGain, proxFilt, warnOsc, warnGain;

function mkNoiseBuf() {
    const sz = 2 * audio.sampleRate;
    const b  = audio.createBuffer(1, sz, audio.sampleRate);
    const d  = b.getChannelData(0);
    for (let i = 0; i < sz; i++) d[i] = Math.random() * 2 - 1;
    return b;
}
function initAudio() {
    if (audio) return;
    audio = new (window.AudioContext || window.webkitAudioContext)();
    const nb = mkNoiseBuf();

    // Cabin rumble
    const amb = audio.createBufferSource(); amb.buffer = nb; amb.loop = true;
    const af  = audio.createBiquadFilter(); af.type = 'lowpass'; af.frequency.value = 120;
    const ag  = audio.createGain(); ag.gain.value = 0.07;
    amb.connect(af); af.connect(ag); ag.connect(audio.destination); amb.start();

    // Proximity hiss
    const pn = audio.createBufferSource(); pn.buffer = nb; pn.loop = true;
    proxFilt = audio.createBiquadFilter(); proxFilt.type = 'bandpass'; proxFilt.frequency.value = 2000;
    proxGain = audio.createGain(); proxGain.gain.value = 0;
    pn.connect(proxFilt); proxFilt.connect(proxGain); proxGain.connect(audio.destination); pn.start();

    // Thruster
    const tn = audio.createBufferSource(); tn.buffer = nb; tn.loop = true;
    const tf  = audio.createBiquadFilter(); tf.type = 'lowpass'; tf.frequency.value = 900;
    thrGain = audio.createGain(); thrGain.gain.value = 0;
    tn.connect(tf); tf.connect(thrGain); thrGain.connect(audio.destination); tn.start();

    // Warning beep oscillator
    warnOsc  = audio.createOscillator(); warnOsc.type = 'square'; warnOsc.frequency.value = 880;
    warnGain = audio.createGain(); warnGain.gain.value = 0;
    warnOsc.connect(warnGain); warnGain.connect(audio.destination); warnOsc.start();
}
function setThrAudio(on) { if (!thrGain) return; thrGain.gain.setTargetAtTime(on?0.35:0, audio.currentTime, 0.03); }
function setProxAudio(r) {
    if (!proxGain) return;
    const t = audio.currentTime;
    const i = Math.max(0, 1 - r/40);
    proxGain.gain.setTargetAtTime(i * 0.18, t, 0.1);
    proxFilt.frequency.setTargetAtTime(1200 + i*3500, t, 0.1);
}
function setWarnBeep(on) { if (!warnGain) return; warnGain.gain.setTargetAtTime(on?0.12:0, audio.currentTime, 0.05); }

function playImpact() {
    if (!audio) return;
    const t = audio.currentTime;
    const nb2 = mkNoiseBuf();
    const s = audio.createBufferSource(); s.buffer = nb2;
    const f = audio.createBiquadFilter(); f.type = 'lowpass'; f.frequency.setValueAtTime(500,t); f.frequency.exponentialRampToValueAtTime(60,t+0.9);
    const g = audio.createGain(); g.gain.setValueAtTime(2.0,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.9);
    s.connect(f); f.connect(g); g.connect(audio.destination); s.start(t); s.stop(t+0.9);
    // thud
    const o = audio.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(90,t); o.frequency.exponentialRampToValueAtTime(18,t+0.3);
    const og=audio.createGain(); og.gain.setValueAtTime(1.2,t); og.gain.exponentialRampToValueAtTime(0.001,t+0.3);
    o.connect(og); og.connect(audio.destination); o.start(t); o.stop(t+0.3);
}
function playRendezvous() {
    if (!audio) return;
    const t = audio.currentTime;
    [440,554,659,880].forEach((f,i)=>{
        const o=audio.createOscillator(); o.type='sine'; o.frequency.value=f;
        const g=audio.createGain(); g.gain.setValueAtTime(0,t+i*0.12);
        g.gain.linearRampToValueAtTime(0.25,t+i*0.12+0.06);
        g.gain.exponentialRampToValueAtTime(0.001,t+i*0.12+0.4);
        o.connect(g); g.connect(audio.destination); o.start(t+i*0.12); o.stop(t+i*0.12+0.4);
    });
}
function playDock() {
    if (!audio) return;
    const t = audio.currentTime;
    [[320,0.6,0.9],[240,0.4,0.5],[180,0.3,0.3]].forEach(([f,st,dur])=>{
        const o1=audio.createOscillator(),o2=audio.createOscillator(),g=audio.createGain();
        o1.type='square'; o2.type='sawtooth';
        o1.frequency.setValueAtTime(f,t+st); o1.frequency.exponentialRampToValueAtTime(f*0.5,t+st+dur);
        o2.frequency.setValueAtTime(f*1.5,t+st); o2.frequency.exponentialRampToValueAtTime(f*0.8,t+st+dur);
        g.gain.setValueAtTime(0.8,t+st); g.gain.exponentialRampToValueAtTime(0.001,t+st+dur);
        o1.connect(g); o2.connect(g); g.connect(audio.destination);
        o1.start(t+st); o2.start(t+st); o1.stop(t+st+dur); o2.stop(t+st+dur);
    });
}

// ═══════════════════════════════════════════════════════
// DEBRIS / ASTEROID SYSTEM
// ═══════════════════════════════════════════════════════
let debris = [];
let hazardSats = [];

function mkAsteroid(zMin, zMax) {
    const sides = 6 + Math.floor(Math.random() * 5);
    const r     = 2.5 + Math.random() * 6;
    const verts = [];
    for (let i = 0; i < sides; i++) {
        const a = (i / sides) * Math.PI * 2;
        const d = r * (0.65 + Math.random() * 0.35);
        verts.push({ x: Math.cos(a)*d, y: Math.sin(a)*d });
    }
    return {
        pos:   { x: (Math.random()-0.5)*60, y: (Math.random()-0.5)*40, z: zMin + Math.random()*(zMax-zMin) },
        vel:   { x: (Math.random()-0.5)*0.012, y: (Math.random()-0.5)*0.008, z: (Math.random()-0.5)*0.006 },
        rot:   0,
        rotV:  (Math.random()-0.5)*0.03,
        verts, r,
        radius: r * 1.1,
        type: 'asteroid'
    };
}

function mkDebrisPiece(zMin, zMax) {
    return {
        pos:   { x: (Math.random()-0.5)*50, y: (Math.random()-0.5)*30, z: zMin + Math.random()*(zMax-zMin) },
        vel:   { x: (Math.random()-0.5)*0.018, y: (Math.random()-0.5)*0.014, z: (Math.random()-0.5)*0.009 },
        rot:   0,
        rotV:  (Math.random()-0.5)*0.05,
        size:  1.5 + Math.random() * 3.5,
        type: 'debris'
    };
}

function mkHazardSat(zPos) {
    // A dead satellite drifting on crossing trajectory
    return {
        pos: { x: -45 + Math.random()*10, y: (Math.random()-0.5)*20, z: zPos },
        vel: { x: 0.014 + Math.random()*0.008, y: (Math.random()-0.5)*0.006, z: -0.04 + Math.random()*0.02 },
        rot: 0,
        rotV: 0.008,
        radius: 8,
        type: 'hazardSat'
    };
}

function spawnDebrisField() {
    debris = [];
    hazardSats = [];
    // Asteroid belt 80m → 110m
    for (let i = 0; i < 10; i++) debris.push(mkAsteroid(80, 112));
    // Scattered debris 30m → 80m
    for (let i = 0; i < 18; i++) debris.push(mkDebrisPiece(30, 80));
    // 2 crossing hazard sats
    hazardSats.push(mkHazardSat(95));
    hazardSats.push(mkHazardSat(55));
}

// ═══════════════════════════════════════════════════════
// TARGET SATELLITE (derelict ISS-7R)
// ═══════════════════════════════════════════════════════
let target = {
    pos: { x: 0, y: 0, z: 0 },      // tracks player's x/y offset from dock
    dockPos: { x: 0, y: 0 },         // where the docking collar IS (drifts slightly)
    vel: { x: 0.008, y: -0.005 },    // drift velocity (player must match)
    collarAngle: 0,                   // rotating collar angle
    collarSpeed: 0.018,               // rad/frame
    collarLocked: false,
    driftAccum: { x: 0, y: 0 }
};

// ═══════════════════════════════════════════════════════
// WAYPOINT RING
// ═══════════════════════════════════════════════════════
let waypoint = {
    z: RENDEZVOUS_Z,
    passed: false,
    pulseT: 0
};

// ═══════════════════════════════════════════════════════
// PLAYER STATE
// ═══════════════════════════════════════════════════════
let S = {
    pos: { x: 0, y: 0, z: 140 },
    vel: { x: 0, y: 0, z: -0.15 },
    fuel: 100,
    active: false,
    view: 'FPV',       // FPV | SIDE
    input: 'KEYBOARD',
    frame: 0,
    phase: 1,          // 1=intercept 2=rendezvous 3=approach 4=dock
    velMatched: false,
    collarAligned: false,
    debrisWarning: false,
    dead: false
};

const keys  = {};
const mouse = { x:0, y:0, in:false };

// ═══════════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════════
function init() {
    window.addEventListener('keydown', e => {
        keys[e.code] = true;
        if (e.code==='KeyT') { S.input = S.input==='KEYBOARD'?'MOUSE':'KEYBOARD'; }
        if (e.code==='KeyV') { S.view  = S.view==='FPV'?'SIDE':'FPV'; }
    });
    window.addEventListener('keyup', e => keys[e.code]=false);
    wrap.addEventListener('mousemove', e => {
        const r = wrap.getBoundingClientRect();
        mouse.x = (e.clientX-(r.left+r.width/2))/(r.width/2);
        mouse.y = (e.clientY-(r.top+r.height/2))/(r.height/2);
        mouse.in = true;
    });
    wrap.addEventListener('mouseleave', ()=>mouse.in=false);
    resize();
    window.addEventListener('resize', resize);
    requestAnimationFrame(loop);
}

function resize() {
    canvas.width  = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
}

function startSim() {
    initAudio();
    S.pos   = { x: (Math.random()-0.5)*12, y: (Math.random()-0.5)*8, z: 140 };
    S.vel   = { x: 0, y: 0, z: -0.15 };
    S.fuel  = 100;
    S.frame = 0;
    S.phase = 1;
    S.active = true;
    S.dead   = false;
    S.velMatched = false;
    S.collarAligned = false;

    // Randomise target drift
    target.vel = { x: 0.006 + Math.random()*0.006, y: -0.004 - Math.random()*0.004 };
    target.collarAngle = 0;
    target.collarLocked = false;
    target.dockPos = { x: 0, y: 0 };
    target.driftAccum = { x: 0, y: 0 };

    waypoint.passed = false;
    waypoint.pulseT = 0;

    spawnDebrisField();
    setPhaseUI(1);

    flash.style.background = '';
    flash.style.opacity = 0;
    modal.style.display = 'none';
}

function setPhaseUI(p) {
    S.phase = p;
    ['ph1','ph2','ph3','ph4'].forEach((id,i)=>{
        const el = document.getElementById(id);
        el.className = 'phase-node';
        if (i+1 < p)  el.classList.add('done');
        if (i+1 === p) el.classList.add('active');
    });
    document.getElementById('v-phase').innerText = ['INTERCEPT','RENDEZVOUS','APPROACH','DOCK'][p-1];
}

// ═══════════════════════════════════════════════════════
// UPDATE
// ═══════════════════════════════════════════════════════
function update() {
    if (!S.active) return;
    S.frame++;
    let thr = false;

    // ── INPUT ──
    if (S.fuel > 0) {
        if (S.input === 'KEYBOARD') {
            if (S.view === 'FPV') {
                if (keys['KeyW']||keys['ArrowUp'])    { S.vel.y += THRUST; thr=true; }
                if (keys['KeyS']||keys['ArrowDown'])  { S.vel.y -= THRUST; thr=true; }
                if (keys['KeyA']||keys['ArrowLeft'])  { S.vel.x -= THRUST; thr=true; }
                if (keys['KeyD']||keys['ArrowRight']) { S.vel.x += THRUST; thr=true; }
                if (keys['KeyQ']) { S.vel.z += THRUST; thr=true; }
                if (keys['KeyE']) { S.vel.z -= THRUST; thr=true; }
            } else {
                if (keys['KeyW']||keys['ArrowUp'])    { S.vel.y += THRUST; thr=true; }
                if (keys['KeyS']||keys['ArrowDown'])  { S.vel.y -= THRUST; thr=true; }
                if (keys['KeyA']||keys['ArrowLeft'])  { S.vel.z += THRUST; thr=true; }
                if (keys['KeyD']||keys['ArrowRight']) { S.vel.z -= THRUST; thr=true; }
            }
        } else if (mouse.in) {
            S.vel.x += mouse.x * 0.00025;
            S.vel.y -= mouse.y * 0.00025;
            thr = true;
        }
        if (keys['Space']) {
            S.vel.x *= BRAKE; S.vel.y *= BRAKE; S.vel.z *= BRAKE;
            S.fuel -= 0.10; thr = true;
        }
    }

    setThrAudio(thr);
    if (thr) S.fuel -= 0.04;

    // ── SOLAR DRIFT ──
    S.vel.x += SOLAR_DRIFT;

    // ── INTEGRATE ──
    S.pos.x += S.vel.x;
    S.pos.y += S.vel.y;
    S.pos.z += S.vel.z;

    // ── DEBRIS PHYSICS ──
    for (const d of debris) {
        d.pos.x += d.vel.x;
        d.pos.y += d.vel.y;
        d.pos.z += d.vel.z;
        d.rot   += d.rotV;
        // Wrap Z
        if (d.pos.z > 160) d.pos.z = 10;
        if (d.pos.z < 5)   d.pos.z = 150;
    }
    for (const hs of hazardSats) {
        hs.pos.x += hs.vel.x;
        hs.pos.y += hs.vel.y;
        hs.pos.z += hs.vel.z;
        hs.rot   += hs.rotV;
        if (hs.pos.z < 0) hs.pos.z = 150 + Math.random()*20;
        if (hs.pos.x > 80) { hs.vel.x *= -1; }
    }

    // ── TARGET DRIFT ──
    target.driftAccum.x += target.vel.x;
    target.driftAccum.y += target.vel.y;
    target.dockPos.x = target.driftAccum.x;
    target.dockPos.y = target.driftAccum.y;
    target.collarAngle += target.collarSpeed;

    // ── PHASE LOGIC ──
    const lateralErr = Math.sqrt((S.pos.x - target.dockPos.x)**2 + (S.pos.y - target.dockPos.y)**2);
    const speed      = Math.abs(S.vel.z * 10);
    const relVx      = S.vel.x - target.vel.x;
    const relVy      = S.vel.y - target.vel.y;
    const relV       = Math.sqrt(relVx*relVx + relVy*relVy) * 100;

    // Waypoint check
    if (!waypoint.passed && S.pos.z <= waypoint.z + 1 && S.pos.z >= waypoint.z - 4) {
        if (lateralErr < 6 && relV < 3.5) {
            waypoint.passed = true;
            playRendezvous();
            setPhaseUI(2);
        }
    }

    if (waypoint.passed && S.pos.z < PHASE_APPROACH_Z && S.phase < 3) setPhaseUI(3);
    if (S.pos.z <= DOCK_RANGE) checkDock(speed, lateralErr);
    if (S.pos.z > 310) endMission("COMMS LOST","Vessel beyond operational range.");
    if (S.fuel <= 0 && S.phase < 4) setWarnBeep(true);
    else setWarnBeep(false);

    // ── PROXIMITY / COLLISION CHECK ──
    let minDebrisDist = 9999;
    const allObstacles = [...debris, ...hazardSats];
    for (const d of allObstacles) {
        const dx = S.pos.x - d.pos.x;
        const dy = S.pos.y - d.pos.y;
        const dz = S.pos.z - d.pos.z;
        const dist3d = Math.sqrt(dx*dx + dy*dy + dz*dz);
        const collRadius = d.type==='hazardSat' ? 6 : (d.r || d.size || 4) * 0.9;

        if (dist3d < collRadius + 1.5) {
            // COLLISION
            playImpact();
            flash.style.background = '#ff0000';
            flash.style.opacity = 1;
            setTimeout(()=>{ flash.style.opacity=0; }, 250);
            endMission("STRUCTURAL FAILURE", `Debris impact at ${dist3d.toFixed(1)}m. Hull integrity lost.`);
            return;
        }
        if (dist3d < 12) minDebrisDist = Math.min(minDebrisDist, dist3d);
    }
    S.debrisWarning = minDebrisDist < 12;
    setProxAudio(minDebrisDist < 50 ? minDebrisDist : 50);

    // ── COLLAR LOCK CHECK ──
    const collarMod = ((target.collarAngle % (Math.PI/2)) + Math.PI/2) % (Math.PI/2);
    S.collarAligned = collarMod < 0.22 || collarMod > (Math.PI/2 - 0.22);

    // ── TELEMETRY ──
    document.getElementById('v-z').innerText    = Math.max(0, S.pos.z).toFixed(2);
    document.getElementById('v-x').innerText    = (S.pos.x - target.dockPos.x).toFixed(2);
    document.getElementById('v-y').innerText    = (S.pos.y - target.dockPos.y).toFixed(2);
    document.getElementById('v-vz').innerText   = (S.vel.z * 10).toFixed(2);
    document.getElementById('v-fuel').innerText = Math.max(0, S.fuel).toFixed(0);
    document.getElementById('v-tvx').innerText  = (target.vel.x * 100).toFixed(2);
    document.getElementById('v-tvy').innerText  = (target.vel.y * 100).toFixed(2);
    document.getElementById('v-relv').innerText = relV.toFixed(2);
    document.getElementById('v-collar').innerText = (target.collarAngle * 180 / Math.PI % 360).toFixed(0);

    waypoint.pulseT += 0.07;

    // ── ALIGN STATUS TEXT ──
    const as = document.getElementById('align-stat');
    if (S.debrisWarning)   as.innerHTML = "<span class='warn'>⚠ DEBRIS PROXIMITY</span>";
    else if (S.phase===1)  {
        const toWP = S.pos.z - waypoint.z;
        if (!waypoint.passed) {
            as.innerHTML = toWP > 5 
                ? `<span class='info'>WP IN ${toWP.toFixed(0)}M — MATCH VEL</span>`
                : `<span class='warn'>ENTER WAYPOINT RING</span>`;
        } else {
            as.innerHTML = "<span class='ok'>RENDEZVOUS OK</span>";
        }
    }
    else if (S.phase===2)  {
        if (relV < 2) as.innerHTML = "<span class='ok'>VELOCITY MATCHED</span>";
        else          as.innerHTML = `<span class='warn'>MATCH TGT VELOCITY (ΔV=${relV.toFixed(1)})</span>`;
    }
    else if (S.phase===3) {
        if (!S.collarAligned) as.innerHTML = "<span class='warn'>AWAIT COLLAR LOCK</span>";
        else if (lateralErr > ALIGN_TOL) as.innerHTML = "<span class='warn'>VECTOR MISMATCH</span>";
        else if (speed > MAX_DOCK_SPD)   as.innerHTML = "<span class='warn'>VELOCITY HIGH</span>";
        else as.innerHTML = "<span class='ok'>CLEAR FOR DOCKING</span>";
    }
}

function checkDock(speed, lateralErr) {
    if (!S.collarAligned) {
        playImpact();
        endMission("COLLAR MISMATCH", "Docking collar phase error. Structural contact.");
    } else if (speed > MAX_DOCK_SPD) {
        playImpact();
        endMission("HARD DOCK FAILURE", `Approach velocity ${speed.toFixed(2)} m/s exceeded limit.`);
    } else if (lateralErr > ALIGN_TOL) {
        playImpact();
        endMission("LATCH FAILURE", `Offset ${lateralErr.toFixed(2)}m — probes failed to engage.`);
    } else {
        playDock();
        endMission("MISSION SUCCESS ✓", "ISS-7R docked. Collar secured. Transfer tunnel pressurising.", true);
    }
}

function endMission(title, desc, ok=false) {
    S.active = false;
    setThrAudio(false);
    setWarnBeep(false);
    setPhaseUI(ok ? 4 : S.phase);
    modal.style.display = 'block';
    document.getElementById('m-title').innerText = title;
    document.getElementById('m-title').style.color = ok ? 'var(--ng)' : 'var(--red)';
    document.getElementById('m-desc').innerText = desc;
}

// ═══════════════════════════════════════════════════════
// DRAW
// ═══════════════════════════════════════════════════════
function draw() {
    ctx.fillStyle = 'rgba(2, 4, 8, 0.22)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    const cx = canvas.width/2, cy = canvas.height/2;

    if (S.view === 'FPV') {
        drawStars(cx, cy);
        drawGridFPV(cx, cy);
        drawDebrisFPV(cx, cy);
        drawHazardSatsFPV(cx, cy);
        if (!waypoint.passed) drawWaypointFPV(cx, cy);
        drawCenterGuide(cx, cy);
        drawTargetSatFPV(cx, cy);
        drawHUD(cx, cy);
        drawThrusterHints(cx, cy);
        drawSolarDriftIndicator(cx, cy);
    } else {
        drawSideView(cx, cy);
    }
}

// ── STARS ──
let stars = null;
function drawStars(cx, cy) {
    if (!stars) {
        stars = [];
        for (let i=0; i<200; i++) {
            stars.push({ x: Math.random()*2-1, y: Math.random()*2-1,
                         z: Math.random(), b: 0.3+Math.random()*0.7 });
        }
    }
    for (const s of stars) {
        const sx = cx + s.x * canvas.width * 0.6;
        const sy = cy + s.y * canvas.height * 0.6;
        const sz = s.z * 1.5;
        ctx.fillStyle = `rgba(200,220,255,${s.b * 0.4})`;
        ctx.fillRect(sx, sy, sz, sz);
    }
}

// ── FPV GRID ──
function drawGridFPV(cx, cy) {
    ctx.strokeStyle = 'rgba(0,255,65,0.03)';
    ctx.lineWidth = 1;
    for (let i=-700; i<=700; i+=70) {
        ctx.beginPath(); ctx.moveTo(cx+i, cy-700); ctx.lineTo(cx+i, cy+700); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(cx-700, cy+i); ctx.lineTo(cx+700, cy+i); ctx.stroke();
    }
}

// ── PROJECT WORLD → SCREEN ──
function project(wx, wy, wz, cx, cy) {
    const z = Math.max(0.1, wz);
    const sc = 3200 / (z + 8);
    return { x: cx + wx * sc, y: cy - wy * sc, sc };
}

// ── DEBRIS FPV ──
function drawDebrisFPV(cx, cy) {
    for (const d of debris) {
        const relX = d.pos.x - S.pos.x;
        const relY = d.pos.y - S.pos.y;
        const relZ = d.pos.z - S.pos.z;
        if (relZ < 0 || relZ > 200) continue;
        const { x, y, sc } = project(relX, relY, relZ, cx, cy);
        if (x < -60 || x > canvas.width+60 || y < -60 || y > canvas.height+60) continue;

        const distToPlayer = Math.sqrt(relX*relX + relY*relY + relZ*relZ);
        const bright = Math.min(1, 15/Math.max(1,distToPlayer));

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(d.rot);

        if (d.type === 'asteroid') {
            ctx.beginPath();
            d.verts.forEach((v,i) => {
                const vx = v.x * sc * 0.04, vy = v.y * sc * 0.04;
                i===0 ? ctx.moveTo(vx,vy) : ctx.lineTo(vx,vy);
            });
            ctx.closePath();
            ctx.strokeStyle = `rgba(120,160,100,${bright*0.9})`;
            ctx.fillStyle   = `rgba(40,60,30,${bright*0.5})`;
            ctx.lineWidth = 1;
            ctx.fill(); ctx.stroke();
        } else {
            // debris chunk
            const sz = d.size * sc * 0.015;
            ctx.strokeStyle = `rgba(180,160,120,${bright*0.8})`;
            ctx.lineWidth = 1;
            ctx.strokeRect(-sz, -sz*0.4, sz*2, sz*0.8);
            ctx.beginPath(); ctx.moveTo(-sz*1.5,0); ctx.lineTo(sz*1.5,0); ctx.stroke();
        }

        // Warning ring if close
        if (distToPlayer < 15) {
            const pulse = (Math.sin(S.frame*0.3+distToPlayer)+1)/2;
            ctx.strokeStyle = `rgba(255,80,0,${0.3+pulse*0.5})`;
            ctx.lineWidth = 1;
            ctx.setLineDash([3,4]);
            ctx.beginPath(); ctx.arc(0,0, Math.max(8, (d.r||d.size||4)*sc*0.06), 0, Math.PI*2); ctx.stroke();
            ctx.setLineDash([]);
        }
        ctx.restore();
    }
}

// ── HAZARD SATS FPV ──
function drawHazardSatsFPV(cx, cy) {
    for (const hs of hazardSats) {
        const relX = hs.pos.x - S.pos.x;
        const relY = hs.pos.y - S.pos.y;
        const relZ = hs.pos.z - S.pos.z;
        if (relZ < 0 || relZ > 200) continue;
        const { x, y, sc } = project(relX, relY, relZ, cx, cy);
        if (x < -80 || x > canvas.width+80 || y < -80 || y > canvas.height+80) continue;

        const distToPlayer = Math.sqrt(relX*relX+relY*relY+relZ*relZ);
        const bright = Math.min(1, 30/Math.max(1,distToPlayer));

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(hs.rot);
        const bw = sc * 0.12, bh = sc * 0.05;
        // Body
        ctx.strokeStyle = `rgba(200,180,100,${bright})`;
        ctx.fillStyle   = `rgba(60,50,20,${bright*0.6})`;
        ctx.lineWidth = 1.5;
        ctx.fillRect(-bw/2, -bh/2, bw, bh);
        ctx.strokeRect(-bw/2, -bh/2, bw, bh);
        // Solar panels
        ctx.strokeStyle = `rgba(100,150,220,${bright*0.8})`;
        ctx.fillStyle   = `rgba(20,40,80,${bright*0.5})`;
        ctx.fillRect(-bw*1.3, -bh*0.4, bw*0.7, bh*0.8);
        ctx.strokeRect(-bw*1.3, -bh*0.4, bw*0.7, bh*0.8);
        ctx.fillRect(bw*0.6, -bh*0.4, bw*0.7, bh*0.8);
        ctx.strokeRect(bw*0.6, -bh*0.4, bw*0.7, bh*0.8);

        // Danger label
        if (distToPlayer < 25) {
            const pulse = (Math.sin(S.frame*0.25)+1)/2;
            ctx.strokeStyle = `rgba(255,50,50,${0.4+pulse*0.5})`;
            ctx.lineWidth = 1;
            ctx.setLineDash([2,3]);
            ctx.beginPath(); ctx.arc(0,0,bw*0.9, 0, Math.PI*2); ctx.stroke();
            ctx.setLineDash([]);
            ctx.restore();
            ctx.fillStyle = 'rgba(255,80,80,0.8)';
            ctx.font = '9px Courier New';
            ctx.fillText('HAZ-SAT', x+4, y-bh*3);
        } else {
            ctx.restore();
        }
    }
}

// ── WAYPOINT RING FPV ──
function drawWaypointFPV(cx, cy) {
    const wz = waypoint.z - S.pos.z;
    if (wz < 0 || wz > 200) return;
    const { x, y, sc } = project(-S.pos.x, -S.pos.y, wz + S.pos.z, cx, cy);
    const r = sc * 5.5;
    const pulse = (Math.sin(waypoint.pulseT)+1)/2;

    ctx.save();
    // Outer glow ring
    ctx.strokeStyle = `rgba(0,229,255,${0.25+pulse*0.35})`;
    ctx.lineWidth = 3 + pulse * 3;
    ctx.setLineDash([8,6]);
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.stroke();
    ctx.setLineDash([]);

    // Inner ring
    ctx.strokeStyle = `rgba(0,229,255,${0.55+pulse*0.35})`;
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(x, y, r*0.35, 0, Math.PI*2); ctx.stroke();

    // Cross spokes
    ctx.strokeStyle = `rgba(0,229,255,0.4)`;
    ctx.lineWidth = 1;
    for (let a=0; a<4; a++) {
        const ang = a*Math.PI/2 + waypoint.pulseT*0.3;
        ctx.beginPath();
        ctx.moveTo(x + Math.cos(ang)*r*0.4, y + Math.sin(ang)*r*0.4);
        ctx.lineTo(x + Math.cos(ang)*r, y + Math.sin(ang)*r);
        ctx.stroke();
    }
    ctx.restore();

    // Label
    const dist = Math.abs(S.pos.z - waypoint.z);
    ctx.fillStyle = `rgba(0,229,255,${0.6+pulse*0.3})`;
    ctx.font = 'bold 9px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(`RENDEZVOUS WP  ${dist.toFixed(0)}M`, x, y - r - 8);
    ctx.fillText('MATCH TGT VELOCITY', x, y - r - 18);
    ctx.textAlign = 'left';
}

// ── CENTER GUIDE SQUARE ──
function drawCenterGuide(cx, cy) {
    const h = GUIDE_HALF;
    ctx.fillStyle = 'rgba(255,255,255,0.035)';
    ctx.fillRect(cx-h, cy-h, h*2, h*2);
    ctx.strokeStyle = 'rgba(255,255,255,0.30)';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(cx-h, cy-h, h*2, h*2);
    const tick=10;
    ctx.strokeStyle = 'rgba(255,255,255,0.65)';
    ctx.lineWidth = 1.5;
    [[cx-h,cy-h],[cx+h,cy-h],[cx-h,cy+h],[cx+h,cy+h]].forEach(([bx,by],i)=>{
        const sx = i%2===0?1:-1, sy = i<2?1:-1;
        ctx.beginPath();
        ctx.moveTo(bx, by + sy*tick); ctx.lineTo(bx, by); ctx.lineTo(bx + sx*tick, by);
        ctx.stroke();
    });
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.beginPath(); ctx.arc(cx,cy,2.5,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.22)';
    ctx.font = '9px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText('ALIGN REF', cx, cy-h-5);
    ctx.textAlign = 'left';
}

// ── TARGET SATELLITE FPV ──
function drawTargetSatFPV(cx, cy) {
    const z = Math.max(0.1, S.pos.z);
    const sc = 3200 / (z + 8);
    const ox = (target.dockPos.x - S.pos.x) * sc;  // relative offset
    // Actually: target dock is at dockPos, player is at S.pos.x
    // In FPV the station is drawn at offset of (player_pos - dock_pos)
    // which converges to center when player is aligned
    const ox2 = (S.pos.x - target.dockPos.x) * sc;
    const oy2 = -(S.pos.y - target.dockPos.y) * sc;

    // Approach corridor
    ctx.strokeStyle = 'rgba(0,255,65,0.07)';
    ctx.lineWidth = 1;
    for (let i=1; i<=3; i++) {
        const s2 = 3200/(z+8+i*28);
        ctx.strokeRect(cx+ox2-s2*2.5, cy+oy2-s2*2.5, s2*5, s2*5);
    }

    // Rotating docking collar
    const cA = target.collarAngle;
    const r  = sc * 4.2;
    ctx.save();
    ctx.translate(cx+ox2, cy+oy2);
    ctx.rotate(cA);

    // Outer octagon
    ctx.strokeStyle = S.collarAligned ? '#ffffff' : 'var(--ng)';
    ctx.lineWidth   = S.collarAligned ? 2.5 : 1.5;
    ctx.beginPath();
    for (let a=0; a<=8; a++) {
        const ang = (a/8)*Math.PI*2;
        const vx = Math.cos(ang)*r, vy = Math.sin(ang)*r;
        a===0 ? ctx.moveTo(vx,vy) : ctx.lineTo(vx,vy);
    }
    ctx.stroke();

    // Inner probe port
    ctx.strokeStyle = S.collarAligned ? 'var(--cya)' : 'var(--ng2)';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(0,0, sc*1.8, 0, Math.PI*2); ctx.stroke();

    // Collar alignment tick (the flat spots)
    ctx.strokeStyle = S.collarAligned ? 'var(--cya)' : 'rgba(255,177,0,0.6)';
    ctx.lineWidth = 2;
    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([nx,ny])=>{
        ctx.beginPath();
        ctx.moveTo(nx*r*0.7, ny*r*0.7);
        ctx.lineTo(nx*r*1.1, ny*r*1.1);
        ctx.stroke();
    });

    // Solar panels on satellite body
    ctx.rotate(-cA); // counter-rotate panels to stay fixed
    ctx.strokeStyle = `rgba(80,120,200,0.7)`;
    ctx.fillStyle   = `rgba(20,40,80,0.5)`;
    const pw = sc*0.5, ph = sc*0.14;
    ctx.fillRect(-r*1.6, -ph/2, r*0.9, ph); ctx.strokeRect(-r*1.6, -ph/2, r*0.9, ph);
    ctx.fillRect(r*0.7,  -ph/2, r*0.9, ph); ctx.strokeRect(r*0.7,  -ph/2, r*0.9, ph);

    ctx.restore();

    // Guide corner lights
    const pulse = (Math.sin(S.frame*0.14)+1)/2;
    ctx.fillStyle = `rgba(255,255,255,${pulse*0.75})`;
    [[-1,-1],[1,-1],[-1,1],[1,1]].forEach(p=>{
        ctx.beginPath();
        ctx.arc(cx+ox2+p[0]*r*0.93, cy+oy2+p[1]*r*0.93, Math.max(1.5,sc*0.18), 0, Math.PI*2);
        ctx.fill();
    });

    // Collar status label
    if (S.phase >= 3) {
        ctx.fillStyle = S.collarAligned ? 'var(--cya)' : 'var(--amb)';
        ctx.font = 'bold 9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(S.collarAligned ? '⊕ COLLAR LOCKED' : '⟳ AWAIT COLLAR', cx+ox2, cy+oy2 - r - 8);
        ctx.textAlign = 'left';
    }
}

// ── HUD ──
function drawHUD(cx, cy) {
    const z  = Math.max(0.1, S.pos.z);
    const sc = 3200 / (z + 8);
    const ox = (S.pos.x - target.dockPos.x) * sc;
    const oy = -(S.pos.y - target.dockPos.y) * sc;
    const lateralErr = Math.sqrt((S.pos.x-target.dockPos.x)**2+(S.pos.y-target.dockPos.y)**2);
    const isAligned  = lateralErr < ALIGN_TOL;

    // Crosshair at port
    ctx.strokeStyle = isAligned ? '#ffffff' : 'var(--ng)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx+ox-28,cy+oy); ctx.lineTo(cx+ox-12,cy+oy);
    ctx.moveTo(cx+ox+28,cy+oy); ctx.lineTo(cx+ox+12,cy+oy);
    ctx.moveTo(cx+ox,cy+oy-28); ctx.lineTo(cx+ox,cy+oy-12);
    ctx.moveTo(cx+ox,cy+oy+28); ctx.lineTo(cx+ox,cy+oy+12);
    ctx.stroke();

    if (isAligned) {
        ctx.strokeRect(cx+ox-14, cy+oy-14, 28, 28);
        const b=160;
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.beginPath();
        ctx.moveTo(cx-b,cy-b+22); ctx.lineTo(cx-b,cy-b); ctx.lineTo(cx-b+22,cy-b);
        ctx.moveTo(cx+b,cy-b+22); ctx.lineTo(cx+b,cy-b); ctx.lineTo(cx+b-22,cy-b);
        ctx.moveTo(cx-b,cy+b-22); ctx.lineTo(cx-b,cy+b); ctx.lineTo(cx-b+22,cy+b);
        ctx.moveTo(cx+b,cy+b-22); ctx.lineTo(cx+b,cy+b); ctx.lineTo(cx+b-22,cy+b);
        ctx.stroke();
    }

    // Velocity vector (amber)
    const vx = cx + (S.pos.x - target.dockPos.x + S.vel.x*55)*sc;
    const vy = cy + (-(S.pos.y - target.dockPos.y) + -S.vel.y*55)*sc;
    ctx.strokeStyle = 'var(--amb)';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(vx,vy,6,0,Math.PI*2); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(vx-8,vy); ctx.lineTo(vx+8,vy);
    ctx.moveTo(vx,vy-8); ctx.lineTo(vx,vy+8);
    ctx.stroke();

    // Trajectory line
    const midZ = Math.max(0.1, S.pos.z + S.vel.z*60);
    const midSc = 3200 / (midZ+8);
    const midX = cx+(S.pos.x-target.dockPos.x+S.vel.x*60)*midSc;
    const midY = cy+(-(S.pos.y-target.dockPos.y)-S.vel.y*60)*midSc;
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(0,255,65,0.4)';
    ctx.setLineDash([4,5]);
    ctx.lineWidth = 1;
    ctx.moveTo(cx,cy);
    ctx.quadraticCurveTo(midX,midY,cx+ox,cy+oy);
    ctx.stroke();
    ctx.setLineDash([]);

    // Debris warning flash border
    if (S.debrisWarning) {
        const p2 = (Math.sin(S.frame*0.4)+1)/2;
        ctx.strokeStyle = `rgba(255,80,0,${0.4+p2*0.5})`;
        ctx.lineWidth = 3;
        ctx.strokeRect(3,3,canvas.width-6,canvas.height-6);
    }

    // Fuel bar (bottom left)
    const fuelW = 120, fuelH = 6;
    const fuelX = 18, fuelY = canvas.height - 36;
    ctx.fillStyle = 'rgba(0,8,0,0.8)';
    ctx.fillRect(fuelX, fuelY, fuelW, fuelH);
    const fPct = Math.max(0,S.fuel)/100;
    const fCol = fPct > 0.4 ? 'var(--ng)' : fPct > 0.2 ? 'var(--amb)' : 'var(--red)';
    ctx.fillStyle = fCol;
    ctx.fillRect(fuelX, fuelY, fuelW*fPct, fuelH);
    ctx.strokeStyle = '#224422';
    ctx.lineWidth = 1;
    ctx.strokeRect(fuelX, fuelY, fuelW, fuelH);
    ctx.fillStyle = fCol;
    ctx.font = '9px Courier New';
    ctx.fillText(`FUEL ${S.fuel.toFixed(0)}%`, fuelX, fuelY - 4);
}

// ── SOLAR DRIFT INDICATOR ──
function drawSolarDriftIndicator(cx, cy) {
    const ix = canvas.width - 36, iy = canvas.height - 80;
    ctx.fillStyle = 'rgba(255,177,0,0.5)';
    ctx.font = '8px Courier New';
    ctx.textAlign = 'right';
    ctx.fillText('SOLAR', ix, iy);
    ctx.fillText('DRIFT→', ix, iy+10);
    ctx.fillStyle = 'rgba(255,177,0,0.7)';
    ctx.beginPath();
    ctx.moveTo(ix-22,iy+22); ctx.lineTo(ix,iy+18);
    ctx.stroke();
    ctx.textAlign = 'left';
}

// ── THRUSTER HINTS FPV ──
function drawThrusterHints(cx, cy) {
    if (!S.active || S.fuel<=0) return;
    const m = 95;
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.font = '9px monospace';
    if (keys['KeyS']||keys['ArrowDown']) { ctx.beginPath(); ctx.moveTo(cx,cy-m); ctx.lineTo(cx-9,cy-m-18); ctx.lineTo(cx+9,cy-m-18); ctx.fill(); ctx.fillText("↑RCS",cx-12,cy-m-22); }
    if (keys['KeyW']||keys['ArrowUp'])   { ctx.beginPath(); ctx.moveTo(cx,cy+m); ctx.lineTo(cx-9,cy+m+18); ctx.lineTo(cx+9,cy+m+18); ctx.fill(); ctx.fillText("↓RCS",cx-12,cy+m+32); }
    if (keys['KeyD']||keys['ArrowRight']) { ctx.beginPath(); ctx.moveTo(cx-m,cy); ctx.lineTo(cx-m-18,cy-9); ctx.lineTo(cx-m-18,cy+9); ctx.fill(); ctx.fillText("←RCS",cx-m-42,cy+4); }
    if (keys['KeyA']||keys['ArrowLeft']) { ctx.beginPath(); ctx.moveTo(cx+m,cy); ctx.lineTo(cx+m+18,cy-9); ctx.lineTo(cx+m+18,cy+9); ctx.fill(); ctx.fillText("→RCS",cx+m+22,cy+4); }
    if (keys['KeyQ']) { ctx.fillText("⊕RCS-AFT",cx-28,cy-m-38); }
    if (keys['KeyE']) { ctx.fillText("⊖RCS-FWD",cx-28,cy-m-38); }
}

// ═══════════════════════════════════════════════════════
// SIDE VIEW
// ═══════════════════════════════════════════════════════
function drawSideView(cx, cy) {
    const zoom = 4.5;
    const sX   = cx + 200;
    const shipX = sX - S.pos.z * zoom;
    const shipY = cy - S.pos.y * zoom;

    // Grid
    ctx.strokeStyle = 'rgba(0,255,65,0.07)';
    ctx.lineWidth = 1;
    for (let x=0; x<canvas.width; x+=50) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
    for (let y=0; y<canvas.height; y+=50) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }

    // Draw debris in side view
    for (const d of debris) {
        const dx = sX - d.pos.z * zoom;
        const dy = cy - d.pos.y * zoom;
        ctx.save();
        ctx.translate(dx, dy);
        ctx.rotate(d.rot);
        if (d.type==='asteroid') {
            const sz = d.r * 0.6;
            ctx.strokeStyle = 'rgba(100,140,80,0.55)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            d.verts.forEach((v,i) => {
                i===0 ? ctx.moveTo(v.x*sz*0.1, v.y*sz*0.1) : ctx.lineTo(v.x*sz*0.1, v.y*sz*0.1);
            });
            ctx.closePath(); ctx.stroke();
        } else {
            const sz = d.size * 0.5;
            ctx.strokeStyle = 'rgba(150,130,90,0.4)';
            ctx.lineWidth = 0.5;
            ctx.strokeRect(-sz,-sz*0.4,sz*2,sz*0.8);
        }
        ctx.restore();
    }

    // Hazard sats side
    for (const hs of hazardSats) {
        const hx = sX - hs.pos.z*zoom;
        const hy = cy - hs.pos.y*zoom;
        ctx.save(); ctx.translate(hx,hy); ctx.rotate(hs.rot);
        ctx.strokeStyle='rgba(200,160,80,0.6)'; ctx.lineWidth=1.5;
        ctx.strokeRect(-10,-4,20,8);
        ctx.strokeRect(-18,-3,6,6); ctx.strokeRect(12,-3,6,6);
        ctx.restore();
    }

    // Waypoint vertical line
    if (!waypoint.passed) {
        const wpX = sX - waypoint.z*zoom;
        const pulse = (Math.sin(waypoint.pulseT)+1)/2;
        ctx.strokeStyle = `rgba(0,229,255,${0.3+pulse*0.4})`;
        ctx.lineWidth = 1.5;
        ctx.setLineDash([6,4]);
        ctx.beginPath(); ctx.moveTo(wpX, cy-80); ctx.lineTo(wpX, cy+80); ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = 'rgba(0,229,255,0.7)';
        ctx.font = '9px Courier New';
        ctx.fillText('WP', wpX+3, cy-83);
    }

    // Station line
    ctx.strokeStyle = 'var(--dg)';
    ctx.lineWidth = 4;
    ctx.beginPath(); ctx.moveTo(sX,cy-100); ctx.lineTo(sX,cy+100); ctx.stroke();

    // Target drift indicator on station
    const tDockY = cy - (S.pos.y - (S.pos.y - target.dockPos.y))*zoom;
    ctx.strokeStyle = 'rgba(0,229,255,0.5)';
    ctx.lineWidth=1.5; ctx.beginPath();
    ctx.arc(sX, cy - target.dockPos.y*zoom, 6, 0, Math.PI*2); ctx.stroke();

    // Docking axis
    ctx.strokeStyle='rgba(0,255,65,0.15)'; ctx.lineWidth=1;
    ctx.setLineDash([12,5]);
    ctx.beginPath(); ctx.moveTo(0,cy); ctx.lineTo(canvas.width,cy); ctx.stroke();
    ctx.setLineDash([]);

    // Y deviation
    if (Math.abs(shipY-cy)>2) {
        const lateralErr = Math.abs(S.pos.y - target.dockPos.y);
        ctx.strokeStyle = lateralErr < ALIGN_TOL ? 'rgba(255,255,255,0.45)' : 'rgba(255,80,80,0.45)';
        ctx.lineWidth=1; ctx.setLineDash([3,5]);
        ctx.beginPath(); ctx.moveTo(shipX,cy); ctx.lineTo(shipX,shipY); ctx.stroke();
        ctx.setLineDash([]);
    }

    // Distance ticks
    ctx.setLineDash([8,5]);
    ctx.strokeStyle='rgba(255,255,255,0.18)'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(shipX,shipY); ctx.lineTo(sX,shipY); ctx.stroke();
    ctx.setLineDash([]);
    for (let d=20; d<S.pos.z; d+=20) {
        const tx=sX-d*zoom;
        ctx.strokeStyle='rgba(0,255,65,0.3)'; ctx.lineWidth=1;
        ctx.beginPath(); ctx.moveTo(tx,shipY-5); ctx.lineTo(tx,shipY+5); ctx.stroke();
        if (d%40===0) { ctx.fillStyle='rgba(0,255,65,0.45)'; ctx.font='8px Courier New'; ctx.fillText(`${d}`,tx-6,shipY+15); }
    }

    // Vel arrow
    const vAL = S.vel.z*zoom*75;
    ctx.strokeStyle='var(--amb)'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.moveTo(shipX,shipY-22); ctx.lineTo(shipX+vAL,shipY-22); ctx.stroke();
    if (Math.abs(vAL)>3) {
        const ad=vAL>0?1:-1;
        ctx.fillStyle='var(--amb)';
        ctx.beginPath(); ctx.moveTo(shipX+vAL+ad*5,shipY-22); ctx.lineTo(shipX+vAL-ad*4,shipY-27); ctx.lineTo(shipX+vAL-ad*4,shipY-17); ctx.fill();
    }
    ctx.fillStyle='var(--amb)'; ctx.font='9px Courier New';
    ctx.fillText(`VZ:${(S.vel.z*10).toFixed(2)}`,shipX-2,shipY-27);

    // Target vel indicators
    ctx.fillStyle='rgba(0,229,255,0.7)'; ctx.font='8px Courier New';
    ctx.fillText(`TGT-VX:${(target.vel.x*100).toFixed(2)}`,sX+6,cy-target.dockPos.y*zoom-10);

    // Ship body
    ctx.save();
    ctx.translate(shipX, shipY);
    const lateralErr2 = Math.abs(S.pos.y-target.dockPos.y);
    ctx.strokeStyle = lateralErr2 < ALIGN_TOL ? '#ffffff' : 'var(--ng)';
    ctx.lineWidth=2;
    ctx.strokeRect(-38,-11,33,22);
    ctx.strokeRect(-5,-5,11,10);
    // thruster indicators
    ctx.fillStyle='rgba(255,255,255,0.8)';
    if (keys['KeyW']||keys['ArrowUp'])   { ctx.beginPath(); ctx.moveTo(-20,14); ctx.lineTo(-15,28); ctx.lineTo(-10,14); ctx.fill(); ctx.fillStyle='#fff'; ctx.font='7px Courier New'; ctx.fillText("RCS↓",-32,36); }
    if (keys['KeyS']||keys['ArrowDown']) { ctx.beginPath(); ctx.moveTo(-20,-14); ctx.lineTo(-15,-28); ctx.lineTo(-10,-14); ctx.fill(); ctx.fillStyle='#fff'; ctx.font='7px Courier New'; ctx.fillText("RCS↑",-32,-32); }
    if (keys['KeyD']||keys['ArrowRight']) { ctx.beginPath(); ctx.moveTo(-42,-7); ctx.lineTo(-60,0); ctx.lineTo(-42,7); ctx.fill(); ctx.fillStyle='#fff'; ctx.font='7px Courier New'; ctx.fillText("AFT",-78,3); }
    if (keys['KeyA']||keys['ArrowLeft']) { ctx.beginPath(); ctx.moveTo(7,-5); ctx.lineTo(22,0); ctx.lineTo(7,5); ctx.fill(); ctx.fillStyle='#fff'; ctx.font='7px Courier New'; ctx.fillText("FWD",25,3); }
    ctx.restore();

    // Range label
    ctx.fillStyle='#fff'; ctx.font='10px Courier New';
    ctx.fillText(`RANGE:${S.pos.z.toFixed(1)}M`,shipX,shipY+28);

    // Fuel bar side view
    const fPct = Math.max(0,S.fuel)/100;
    const fCol = fPct>0.4?'var(--ng)':fPct>0.2?'var(--amb)':'var(--red)';
    ctx.fillStyle='rgba(0,8,0,0.8)'; ctx.fillRect(18,canvas.height-36,120,6);
    ctx.fillStyle=fCol; ctx.fillRect(18,canvas.height-36,120*fPct,6);
    ctx.strokeStyle='#224422'; ctx.lineWidth=1; ctx.strokeRect(18,canvas.height-36,120,6);
}

// ═══════════════════════════════════════════════════════
// LOOP
// ═══════════════════════════════════════════════════════
function loop() { update(); draw(); requestAnimationFrame(loop); }
init();
</script>
</body>
</html>
